% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MQE_proc.R
\name{MQE_proc}
\alias{MQE_proc}
\title{Multi-QTL effect MPP analysis}
\usage{
MQE_proc(pop.name = "MPP_MQE", trait.name = "trait1", mppData = NULL,
  mppData_bi = NULL, Q.eff, par.clu = NULL, VCOV = "h.err",
  threshold = 3, window = 20, backward = TRUE, alpha.bk = 0.05,
  plot.MQE = FALSE, parallel = FALSE, cluster = NULL,
  silence.print = FALSE, output.loc = getwd())
}
\arguments{
\item{pop.name}{\code{Character} name of the studied population.
Default = "MPP_MQE".}

\item{trait.name}{\code{Character} name of the studied trait.
Default = "trait1".}

\item{mppData}{An IBD object of class \code{mppData}
See \code{\link{mppData_form}} for details. Default = NULL.}

\item{mppData_bi}{Required IBS object of class \code{mppData} if the user
wants to allow QTLs with a bi-allelic effect. \strong{The list of marker must
be strictly the same as the one of \code{mppData}.} Default = NULL.}

\item{Q.eff}{\code{Character} vector of possible QTL effects the user want to
test. Elements of Q.eff can be "cr", "par", "anc" or "biall". For details
look at \code{\link{mpp_SIM}}.}

\item{par.clu}{Required argument if the user wants to allow QTLs with an
ancestral effect. \code{interger matrix} representing the results of a parents
genotypes
clustering. The columns represent the parental lines and the rows
the different markers or in between positions. \strong{The columns names must
be the same as the parents list of the mppData object. The rownames must be
the same as the map marker list of the mppData object.} At a particular
position, parents with the same value are assumed to inherit from the same
ancestor. for more details, see \code{\link{USNAM_parClu}} and
\code{\link{parent_cluster}}. Default = NULL.}

\item{VCOV}{\code{Character} expression defining the type of variance
covariance structure used: 1) "h.err" for an homogeneous variance residual term
(HRT) linear model; 2) "h.err.as" for a HRT model fitted by REML using
\code{ASReml-R}; 3) "cr.err" for a cross-specific variance residual terms
(CSRT) model; 4) "pedigree" for a random pedigree term and HRT model;
and 5) "ped_cr.err" for random pedigree and CSRT model.
For more details see \code{\link{mpp_SIM}}. Default = "h.err".}

\item{threshold}{\code{Numeric} value representing the -log10(p-value)
threshold above which a position can be considered as significant.
Significance threshold values can be obtained by permutation using
\code{\link{mpp_perm}} function. Default = 3.}

\item{window}{\code{Numeric} value in centi-Morgan representing the distance
on the left an right of a cofactor position where it is not included in the
model. Default value = 20.}

\item{backward}{\code{Logical} value. If \code{backward = TRUE},
the function performs
a backward elimination on the list of selected QTLs. Default = TRUE.}

\item{alpha.bk}{\code{Numeric} value indicating the significance level for
the backward elimination. Terms with p-values above this value will
iteratively be removed. Default = 0.05.}

\item{plot.MQE}{\code{Logical} value. If \code{plot.MQE = TRUE},
the function will make a plot of the last run of the MQE model
determination using function \code{\link{MQE_plot}}. Default = FALSE.}

\item{parallel}{\code{Logical} value specifying if the function should be
executed in parallel on multiple cores. To run function in parallel user must
provide cluster in the \code{cluster} argument. \strong{Parallelization is
only available for HRT (linear) models \code{VCOV = "h.err"}}.
Default = FALSE.}

\item{cluster}{Cluster object obtained with the function \code{makeCluster()}
from the \code{parallel} package. Default = NULL.}

\item{silence.print}{\code{logical} value specifying if the printing of the
\code{MQE_proc()} function must be silenced. It will not
affect the printing of the other functions called by \code{MQE_proc()},
especially the printing of \code{asreml()}. Default = FALSE.}

\item{output.loc}{Path where a folder will be created to save the results.
By default the function uses the current working directory.}
}
\value{
Return:

\code{List} containing the following items:

\item{n.QTL}{Number of detected QTLs.}

\item{QTL}{\code{Data.frame} with QTL positions.}

\item{R2}{\code{list} containing R squared statistics of the QTL effects.
for details see \code{\link{QTL_R2}} and \code{\link{MQE_R2}} output
sections.}

\item{QTL.effects}{\code{List} of genetic effects per QTL. For details see
\code{\link{MQE_genEffects}} output section.}


Some output files are also saved at the location specified
(\code{output.loc}):

\enumerate{

\item{A QTL report (QTL_REPORT.txt) with: 1) the number of detected QTLs;
2) the global R squared statistics; 3) for each QTL, position information
 and estimated QTL genetic effect per cross or parents (for details see
 \code{\link{MQE_genEffects}}).}

\item{The list of QTLs (QTL.txt).}

\item{The QTL R squared statistics (QTL_R2.txt) (for details see
\code{\link{MQE_R2}} or \code{\link{QTL_R2}}).}

\item{General results of the QTL detection process: Number of QTL and
global adjusted and non-adjusted R squared statistics. (QTL_genResults.txt).}

\item{if \code{plot.MQE = TRUE}, a plot of the last QTL detection run profile
(plot_MQE.pdf) obtained with the function \code{\link{MQE_plot}}.}


}
}
\description{
This function aim at building multi-QTL models in which different QTL effects
(cross-specific, parental, ancestral or bi-allelic) can be assumed at
different loci. The possible QTL effect that the user want to allow must be
specified in \code{Q.eff}. Once the model has been determined it also computes
the QTL genetic effects per cross or parent and global and partial R squared
of the detected QTLs.
}
\details{
The procedure is the following:

\enumerate{

\item{forward regression to determine a multi-QTL model with different
possible assumptions for the QTL effect at different loci. The function use
\code{\link{MQE_forward}}.}

\item{Optional backward elimination (\code{backward = TRUE}) on the final
list of detected QTLs (\code{\link{MQE_BackElim}}).}

\item{Estimation of the QTL genetic effects and R squared statistics
(\code{\link{MQE_genEffects}} and \code{\link{MQE_R2}}).}

\item{Optional plot (\code{plot.MQE = TRUE}) of the last CIM run of the
forward regression using the function \code{\link{MQE_plot}.}

}

}

\strong{WARNING!(1)} The computation of \code{MQE_proc()} function using mixed
models (all models with \code{VCOV} different than \code{"h.err"})
is technically possible but can be irrealistic
in practice due to a reduced computer power. Since a mixed model is computed at
each single position it can take a lot of time. From our estimation it can take
between 20 to 50 times more time than for linear models. If the number of
detected QTL is supposed to be small (until 5) it could still be feasible.

\strong{WARNING! (2)} The estimation of the random pedigree models
(\code{VCOV = "pedigree" and "ped_cr.err"}) can be unstable. Sometimes the
\code{asreml()} function fails to produce a results and returns the following
message: \strong{\code{GIV matrix not positive definite: Singular pivots}}.
So far we were not able to identify the reason of this problem and to
reproduce this error because it seems to happen randomly. From our
experience, trying to re-run the function one or two times should allow
to obtain a result.
}
\examples{

data(USNAM_mppData)
data(USNAM_mppData_bi)
data(USNAM_parClu)

mppData <- USNAM_mppData
mppData_bi <- USNAM_mppData_bi
par.clu <- USNAM_parClu


# Equalize the list of markers of the two mppData objects and par.clu

com.mk.list <- intersect(mppData$map$mk.names, mppData_bi$map$mk.names)

mppData <- mppData_subset(mppData = mppData, mk.list = com.mk.list)
mppData_bi <- mppData_subset(mppData = mppData_bi, mk.list = com.mk.list)
par.clu <- par.clu[rownames(par.clu) \%in\% com.mk.list, ]


\dontrun{

# Specify a location where your results will be saved
my.loc <- "C:/.../..."

MQE <- MQE_proc(pop.name = "USNAM", trait.name = "ULA", mppData = mppData,
                mppData_bi = mppData_bi, Q.eff = c("par", "anc", "biall"),
                par.clu = par.clu, output.loc = my.loc)
                 

# Using parallel

library(parallel)
n.cores <- detectCores()
cluster <- makeCluster(n.cores-1)

MQE <- MQE_proc(pop.name = "USNAM", trait.name = "ULA", mppData = mppData,
                mppData_bi = mppData_bi, Q.eff = c("par", "anc", "biall"),
                par.clu = par.clu, parallel = TRUE, cluster = cluster,
                output.loc = my.loc)
                 
                
}


}
\author{
Vincent Garin
}
\seealso{
\code{\link{mppData_form}}, \code{\link{mpp_perm}},
\code{\link{mpp_SIM}},
\code{\link{MQE_forward}}, \code{\link{MQE_BackElim}},
\code{\link{MQE_genEffects}}, \code{\link{MQE_plot}}, \code{\link{MQE_R2}},
\code{\link{parent_cluster}}, \code{\link{QTL_R2}},
\code{\link{USNAM_parClu}}
}

